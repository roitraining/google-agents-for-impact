from __future__ import annotations

import time, uuid
from typing import Any, Dict, List, Optional

from google import genai
from google.genai import types
from google.cloud import storage
from google.adk.agents import Agent

# =========================
# Config
# =========================
IMAGE_BUCKET = "food-agent-generated-images-dar"  # must be public

# =========================
# Helpers
# =========================
def _ext_for_mime(mime_type: str) -> str:
    m = (mime_type or "").lower()
    if "jpeg" in m or "jpg" in m:
        return "jpg"
    if "webp" in m:
        return "webp"
    if "png" in m:
        return "png"
    if "gif" in m:
        return "gif"
    # default
    return "png"

def _public_gcs_url(bucket: str, blob_name: str) -> str:
    # Public URL that works without auth if bucket is public
    return f"https://storage.googleapis.com/{bucket}/{blob_name}"

def _upload_bytes_to_gcs(
    data: bytes,
    bucket: str,
    mime_type: str = "image/png",
    prefix: str = "generated",
) -> Dict[str, str]:
    client = storage.Client()
    bucket_obj = client.bucket(bucket)

    ext = _ext_for_mime(mime_type)
    blob_name = f"{prefix}/{int(time.time())}-{uuid.uuid4().hex}.{ext}"

    blob = bucket_obj.blob(blob_name)
    # Optionally set cache control if you want CDN/browser caching
    # blob.cache_control = "public, max-age=86400"
    blob.upload_from_string(data, content_type=mime_type)
    public_url = _public_gcs_url(bucket, blob_name)

    return {
        "gcs_uri": f"gs://{bucket}/{blob_name}",
        "public_url": public_url,
        "mime_type": mime_type,
        "filename": blob_name,
        "markdown": f'![{blob_name}]({public_url} "Generated by Imagen")',
    }

# =========================
# Tool
# =========================
def generate_image_tool(
    prompt: str,
    *,
    bucket: str = IMAGE_BUCKET,
    n: int = 1,
    return_text: bool = False,
) -> Dict[str, Any]:
    """
    Generate image(s) with Gemini 2.5 Flash Image (preview),
    upload to a (public) GCS bucket, and return lightweight URLs.

    Returns:
        {
          "status": "success",
          "images": [
            {"public_url": "...", "gcs_uri": "...", "mime_type": "...", "filename": "..."}
          ],
          "text": "optional textual output (if return_text=True)"
        }
    """
    client = genai.Client(vertexai=True, api_key=None)

    contents = [types.Content(role="user", parts=[types.Part.from_text(text=prompt)])]
    # Keep tokens lean: default to IMAGE-only; include TEXT only if requested
    response_modalities = ["IMAGE"] + (["TEXT"] if return_text else [])

    cfg = types.GenerateContentConfig(
        temperature=1.0,
        top_p=0.95,
        max_output_tokens=4096,
        response_modalities=response_modalities,
        safety_settings=[
            types.SafetySetting(category="HARM_CATEGORY_HATE_SPEECH", threshold="OFF"),
            types.SafetySetting(category="HARM_CATEGORY_DANGEROUS_CONTENT", threshold="OFF"),
            types.SafetySetting(category="HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold="OFF"),
            types.SafetySetting(category="HARM_CATEGORY_HARASSMENT", threshold="OFF"),
        ],
    )

    try:
        stream = client.models.generate_content_stream(
            model="gemini-2.5-flash-image-preview",
            contents=contents,
            config=cfg,
        )

        outputs: List[Dict[str, str]] = []
        text_out: List[str] = []

        for chunk in stream:
            cand = getattr(chunk, "candidates", [None])[0]
            if not cand or not cand.content or not getattr(cand.content, "parts", None):
                continue

            for part in cand.content.parts:
                # Optional text (captions/notes)
                if getattr(part, "text", None):
                    text_out.append(part.text)

                # Image bytes
                inline = getattr(part, "inline_data", None)
                if inline and getattr(inline, "data", None):
                    info = _upload_bytes_to_gcs(
                        inline.data,
                        bucket=bucket,
                        mime_type=inline.mime_type or "image/png",
                    )
                    outputs.append(info)
                    if len(outputs) >= n:
                        break

            if len(outputs) >= n:
                break

        if not outputs and not text_out:
            return {"status": "error", "error_message": "No image or text returned."}

        result: Dict[str, Any] = {"status": "success", "images": outputs}
        if return_text and text_out:
            result["text"] = "\n".join(text_out)
        return result

    except Exception as e:
        print("ERROR generating image:", e)
        return {"status": "error", "error_message": str(e)}

# =========================
# Agent
# =========================
agent_generation = types.GenerateContentConfig(
    temperature=0.6,
    top_p=0.9,
    max_output_tokens=2048,
)

image_agent = Agent(
    model="gemini-2.5-flash",   # planner/brain model
    name="imagen_tool_agent",
    instruction=(
        "You generate images based on user prompts. "
        "When asked for an image, call `generate_image_tool` with a concise visual prompt. "
        "Return the Markdown from the tool output to the user so it can be displayed on their website."
    ),
    description="Agent that creates images via a custom tool powered by Gemini 2.5 Flash Image (preview).",
    tools=[generate_image_tool],
    generate_content_config=agent_generation,
)
